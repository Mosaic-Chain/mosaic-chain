//! # Permission NFT Pallet
//!
//! This pallet provides functionality for managing permission with NFTs.
//! Each NFT represents a permission associated with a specific nominal value.
//!
//! The pallet is built on top of the `pallet_nfts` pallet to manage the creation, ownership,
//! and attributes of the permission NFTs. The pallet allows users to mint new permission
//! NFTs, bind/unbind NFTs to/from their accounts
//!
//! ## Overview
//!
//! The pallet provides public functions to:
//!
//! - Mint a new permission NFT with a specific permission and nominal value.
//! - Bind a permission NFT to an account, effectively locking its use.
//! - Unbind a bound permission NFT, releasing its use.
//!
//! ## Configuration
//!
//! The pallet's behavior can be customized by implementing the `Config` trait. This trait defines
//! various associated types and constants required for the pallet's operation. Some key
//! configuration parameters include:
//!
//! - `RuntimeEvent`: Specifies the event type emitted by the pallet.
//! - `PalletId`: The ID of the pallet used to derive collection owner's addresses.
//! - `PrivilegedOrigin`: The origin authorized to mint tokens and modify them.
//! - `Balance`: The balance type used for nominal value and related calculations.
//! - `Permission`: The permission type stored among the token's attributes.
//! - `ItemIdSuccession`: The way the next item's ID is generated.
//! - `WeightInfo`: Type representing the weight of the pallet operations.

// clippy::pedantic warnings coming from code generated by macros that annoy the hell out of me
#![allow(
	clippy::must_use_candidate,
	clippy::cast_possible_truncation,
	dead_code,
	clippy::used_underscore_binding,
	clippy::wildcard_imports
)]
#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;
mod weights;

use codec::Codec;
use frame_support::{
	pallet_prelude::*,
	traits::{
		tokens::nonfungibles_v2::{Create, Inspect, Mutate, Transfer},
		BuildGenesisConfig, Incrementable,
	},
	PalletError, PalletId,
};
use frame_system::pallet_prelude::OriginFor;
use pallet_nfts::{
	CollectionConfig, CollectionSettings, Config as NftsConfig, ItemConfig, ItemSettings,
	MintSettings, MintType, Pallet as NftsPallet,
};
use sp_runtime::{
	traits::{AccountIdConversion, AtLeast32BitUnsigned},
	DispatchError, FixedPointOperand, Perbill,
};
use sp_std::vec::Vec as SpVec;

pub use pallet::*;
pub use weights::*;

// TODO: Once the pallet is ready turn off dev_mode
#[frame_support::pallet(dev_mode)]
pub mod pallet {
	use super::*;

	#[pallet::pallet]
	pub struct Pallet<T>(_);

	/// Configure the pallet by specifying the parameters and types on which it depends.
	#[pallet::config]
	pub trait Config: frame_system::Config + NftsConfig {
		/// Because this pallet emits events, it depends on the runtime's definition of an event.
		type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;

		/// The id of the pallet from witch the collection owner's address is derived.
		#[pallet::constant]
		type PalletId: Get<PalletId>;

		/// The origin that is authorized to mint new tokens and modify existing ones.
		type PrivilegedOrigin: EnsureOrigin<Self::RuntimeOrigin>;

		/// The permission type that is stored amongst the token's attributes.
		type Permission: Parameter + Member + Codec + MaybeSerializeDeserialize;

		/// The balance type that is stored amongst the token's attributes.
		type Balance: Parameter
			+ Member
			+ Codec
			+ AtLeast32BitUnsigned
			+ MaybeSerializeDeserialize
			+ FixedPointOperand;

		/// Type representing the weight of this pallet
		type WeightInfo: WeightInfo;
	}

	/// The id of the collection that's managed by this pallet.
	#[pallet::storage]
	#[pallet::getter(fn collection_id)]
	pub type CollectionId<T: Config> = StorageValue<_, <T as NftsConfig>::CollectionId>;

	/// The account who owns the managed collection. Derived from the `PalletId`.
	#[pallet::storage]
	#[pallet::getter(fn pallet_account_id)]
	pub type PalletAccountId<T: Config> = StorageValue<_, T::AccountId>;

	#[pallet::storage]
	#[pallet::getter(fn next_item_id)]
	pub type NextItemId<T: Config> = StorageValue<_, <T as NftsConfig>::ItemId>;

	#[pallet::storage]
	pub type BoundTokens<T: Config> = StorageMap<_, Twox64Concat, T::AccountId, T::ItemId>;

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		/// A token has been minted to the specified account.
		TokenCreated { account: T::AccountId, item_id: <T as NftsConfig>::ItemId },

		/// A token has been successfully bound
		TokenBound { item_id: <T as NftsConfig>::ItemId },

		/// A token has been successfully unbound
		TokenUnbound { item_id: <T as NftsConfig>::ItemId },
	}

	#[derive(
		Debug, PartialEq, Eq, Copy, Clone, TypeInfo, Encode, Decode, PalletError, MaxEncodedLen,
	)]
	#[repr(u8)]
	pub enum AttributeKey {
		Permission = 0,
		NominalValue = 1,
		IssuedNominalValue = 2,
	}

	impl From<AttributeKey> for &[u8] {
		fn from(value: AttributeKey) -> Self {
			match value {
				AttributeKey::Permission => b"PERM",
				AttributeKey::NominalValue => b"NOMV",
				AttributeKey::IssuedNominalValue => b"INOV",
			}
		}
	}

	#[pallet::error]
	pub enum Error<T> {
		CollectionNotInitialized,
		InvalidAttribute {
			/// Key of NFT attribute that could not be decoded
			attribute_key: AttributeKey,
		},
		ItemNotInitialized,
		WrongOwner,
		AlreadyBound,
		NotBound,
		InvalidNominalValue,
	}

	#[pallet::genesis_config]
	pub struct GenesisConfig<T: Config> {
		pub unstaked_permission_holders: SpVec<(T::AccountId, T::Permission, T::Balance)>,
	}

	impl<T: Config> Default for GenesisConfig<T> {
		fn default() -> Self {
			Self { unstaked_permission_holders: SpVec::new() }
		}
	}

	#[pallet::genesis_build]
	impl<T: Config> BuildGenesisConfig for GenesisConfig<T>
	where
		T::ItemId: Incrementable,
	{
		fn build(&self) {
			let admin: T::AccountId = <T as Config>::PalletId::get().into_account_truncating();

			PalletAccountId::<T>::put(admin.clone());

			let collection_id = NftsPallet::<T>::create_collection(
				&admin,
				&admin,
				&CollectionConfig {
					settings: CollectionSettings::default(),
					max_supply: None,
					mint_settings: MintSettings {
						mint_type: MintType::Issuer,
						price: None,
						start_block: None,
						end_block: None,
						default_item_settings: ItemSettings::default(),
					},
				},
			)
			.expect("could create collection");

			CollectionId::<T>::put(collection_id);
			NextItemId::<T>::put(T::ItemId::initial_value().expect("Item Id has initial value"));

			for (account_id, permission, nominal_value) in &self.unstaked_permission_holders {
				Pallet::<T>::do_mint_permission_token(account_id, permission, nominal_value)
					.expect("could mint new permission token");
			}
		}
	}

	impl<T: Config> Pallet<T>
	where
		T::ItemId: Incrementable,
	{
		/// Mint a new permission NFT with provided permission and nominal value.
		///
		/// # Parameters
		///
		/// - `account_id`: Account to assign the NFT.
		/// - `permission`: Permission associated with the NFT.
		/// - `nominal_value`: Nominal value of the NFT.
		///
		/// # Errors
		///
		/// - Pallet is not initialized.
		/// - Error during minting process.
		pub fn do_mint_permission_token(
			account_id: &T::AccountId,
			permission: &T::Permission,
			nominal_value: &T::Balance,
		) -> Result<<T as NftsConfig>::ItemId, DispatchError> {
			nominal_value.using_encoded(|nominal_value| {
				permission.using_encoded(|permission| {
					Self::create_token(account_id, permission, nominal_value)
				})
			})
		}

		/// Returns the nominal value of the provided item
		///
		/// # Errors
		///  - Pallet is not initialized
		///  - NFT is not initialized
		///  - Failed to decode data
		pub fn nominal_value_of(
			item_id: &<T as NftsConfig>::ItemId,
		) -> Result<T::Balance, DispatchError> {
			let collection_id =
				Self::collection_id().ok_or(Error::<T>::CollectionNotInitialized)?;

			Self::decode_nominal_value(&collection_id, item_id)
		}

		// Returns the maximum nominal value of the provided item
		///
		/// # Errors
		///  - Pallet is not initialized
		///  - NFT is not initialized
		///  - Failed to decode data
		pub fn issued_nominal_value_of(
			item_id: &<T as NftsConfig>::ItemId,
		) -> Result<T::Balance, DispatchError> {
			let collection_id =
				Self::collection_id().ok_or(Error::<T>::CollectionNotInitialized)?;

			Self::decode_issued_nominal_value(&collection_id, item_id)
		}

		/// Returns the permission of the provided item
		///
		/// # Errors
		///  - Pallet is not initialized
		///  - NFT is not initialized
		///  - Failed to decode data
		pub fn permission_of(
			item_id: &<T as NftsConfig>::ItemId,
		) -> Result<T::Permission, DispatchError> {
			let collection_id =
				Self::collection_id().ok_or(Error::<T>::CollectionNotInitialized)?;

			Self::decode_permission(&collection_id, item_id)
		}

		fn encode_nominal_value(
			collection_id: &<T as NftsConfig>::CollectionId,
			item_id: &<T as NftsConfig>::ItemId,
			nominal_value: &T::Balance,
		) -> DispatchResult {
			nominal_value.using_encoded(|nominal_value| {
				<NftsPallet<T> as Mutate<_, _>>::set_attribute(
					collection_id,
					item_id,
					AttributeKey::NominalValue.into(),
					nominal_value,
				)
			})
		}

		fn encode_issued_nominal_value(
			collection_id: &<T as NftsConfig>::CollectionId,
			item_id: &<T as NftsConfig>::ItemId,
			nominal_value: &T::Balance,
		) -> DispatchResult {
			nominal_value.using_encoded(|nominal_value| {
				<NftsPallet<T> as Mutate<_, _>>::set_attribute(
					collection_id,
					item_id,
					AttributeKey::IssuedNominalValue.into(),
					nominal_value,
				)
			})
		}

		fn encode_permission(
			collection_id: &<T as NftsConfig>::CollectionId,
			item_id: &<T as NftsConfig>::ItemId,
			permission: &T::Permission,
		) -> DispatchResult {
			permission.using_encoded(|permission| {
				<NftsPallet<T> as Mutate<_, _>>::set_attribute(
					collection_id,
					item_id,
					AttributeKey::Permission.into(),
					permission,
				)
			})
		}

		fn decode_nominal_value(
			collection_id: &<T as NftsConfig>::CollectionId,
			item_id: &<T as NftsConfig>::ItemId,
		) -> Result<T::Balance, DispatchError> {
			T::Balance::decode(
				&mut NftsPallet::<T>::system_attribute(
					collection_id,
					Some(item_id),
					AttributeKey::NominalValue.into(),
				)
				.ok_or(Error::<T>::ItemNotInitialized)?
				.as_slice(),
			)
			.map_err(|_| {
				Error::<T>::InvalidAttribute { attribute_key: AttributeKey::NominalValue }.into()
			})
		}

		fn decode_issued_nominal_value(
			collection_id: &<T as NftsConfig>::CollectionId,
			item_id: &<T as NftsConfig>::ItemId,
		) -> Result<T::Balance, DispatchError> {
			T::Balance::decode(
				&mut NftsPallet::<T>::system_attribute(
					collection_id,
					Some(item_id),
					AttributeKey::IssuedNominalValue.into(),
				)
				.ok_or(Error::<T>::ItemNotInitialized)?
				.as_slice(),
			)
			.map_err(|_| {
				Error::<T>::InvalidAttribute { attribute_key: AttributeKey::IssuedNominalValue }
					.into()
			})
		}

		fn decode_permission(
			collection_id: &<T as NftsConfig>::CollectionId,
			item_id: &<T as NftsConfig>::ItemId,
		) -> Result<T::Permission, DispatchError> {
			T::Permission::decode(
				&mut NftsPallet::<T>::system_attribute(
					collection_id,
					Some(item_id),
					AttributeKey::Permission.into(),
				)
				.ok_or(Error::<T>::ItemNotInitialized)?
				.as_slice(),
			)
			.map_err(|_| {
				Error::<T>::InvalidAttribute { attribute_key: AttributeKey::Permission }.into()
			})
		}

		fn init_attributes(
			collection_id: &<T as NftsConfig>::CollectionId,
			item_id: &<T as NftsConfig>::ItemId,
			permission: &[u8],
			nominal_value: &[u8],
		) -> DispatchResult {
			<NftsPallet<T> as Mutate<_, _>>::set_attribute(
				collection_id,
				item_id,
				AttributeKey::Permission.into(),
				permission,
			)?;

			<NftsPallet<T> as Mutate<_, _>>::set_attribute(
				collection_id,
				item_id,
				AttributeKey::NominalValue.into(),
				nominal_value,
			)?;

			<NftsPallet<T> as Mutate<_, _>>::set_attribute(
				collection_id,
				item_id,
				AttributeKey::IssuedNominalValue.into(),
				nominal_value,
			)
		}

		fn create_token(
			account_id: &T::AccountId,
			permission: &[u8],
			nominal_value: &[u8],
		) -> Result<<T as NftsConfig>::ItemId, DispatchError> {
			let item_id = Self::next_item_id().ok_or(Error::<T>::CollectionNotInitialized)?;
			let collection_id =
				Self::collection_id().ok_or(Error::<T>::CollectionNotInitialized)?;

			NftsPallet::<T>::mint_into(
				&collection_id,
				&item_id,
				account_id,
				&ItemConfig::default(),
				true,
			)?;

			Self::init_attributes(&collection_id, &item_id, permission, nominal_value)?;

			Pallet::<T>::deposit_event(Event::<T>::TokenCreated {
				account: account_id.clone(),
				item_id,
			});

			let next_item_id = item_id.increment().ok_or(Error::<T>::ItemNotInitialized)?;

			NextItemId::<T>::put(next_item_id);

			Ok(item_id)
		}
	}

	// TODO: calculate weights
	#[pallet::call]
	impl<T: Config> Pallet<T>
	where
		T::ItemId: Incrementable,
	{
		/// Mint a new permission NFT with provided permission and nominal value.
		///
		/// # Parameters
		///
		/// - `origin`: Caller's origin.
		/// - `account_id`: Account to assign the NFT.
		/// - `permission`: Permission associated with the NFT.
		/// - `nominal_value`: Nominal value of the NFT.
		///
		/// # Errors
		///
		/// - Pallet is not initialized.
		/// - Origin is not authorized.
		/// - Error during minting process.
		#[pallet::call_index(0)]
		pub fn mint_permission_token(
			origin: OriginFor<T>,
			account_id: T::AccountId,
			permission: T::Permission,
			nominal_value: T::Balance,
		) -> DispatchResult {
			T::PrivilegedOrigin::ensure_origin(origin)?;
			permission.using_encoded(|permission| {
				nominal_value.using_encoded(|nominal_value| {
					Self::create_token(&account_id, permission, nominal_value).map(|_| ())
				})
			})
		}
	}

	impl<T: Config>
		utils::traits::NftStaking<
			T::AccountId,
			T::Balance,
			T::Permission,
			<T as NftsConfig>::ItemId,
		> for Pallet<T>
	where
		T::ItemId: Incrementable,
	{
		fn mint(
			account_id: &T::AccountId,
			permission: &T::Permission,
			nominal_value: &T::Balance,
		) -> Result<<T as NftsConfig>::ItemId, DispatchError> {
			Self::do_mint_permission_token(account_id, permission, nominal_value)
		}

		// Bind a permission NFT to an account, locking its use.
		/// Returns the associated permission an nominal value decoded from token.
		///
		/// # Errors
		///
		/// - Pallet is not initialized.
		/// - NFT is not owned by caller.
		/// - An NFT is already bound.
		fn bind(
			account_id: &T::AccountId,
			item_id: &<T as NftsConfig>::ItemId,
		) -> Result<(T::Permission, T::Balance), DispatchError> {
			let collection_id =
				Self::collection_id().ok_or(Error::<T>::CollectionNotInitialized)?;

			ensure!(
				NftsPallet::<T>::owner(collection_id, *item_id)
					.is_some_and(|owner| owner == *account_id),
				Error::<T>::WrongOwner
			);

			BoundTokens::<T>::mutate_exists(account_id, |maybe_item| {
				if maybe_item.is_some() {
					Err(Error::<T>::AlreadyBound.into())
				} else {
					*maybe_item = Some(*item_id);

					// If its already locked, we don't want this to fail
					match <NftsPallet<T> as Transfer<_>>::disable_transfer(&collection_id, item_id)
					{
						Err(e) if e != pallet_nfts::Error::<T>::ItemLocked.into() => {
							return Err(e);
						},
						_ => {},
					}

					let permission = Self::decode_permission(&collection_id, item_id)?;
					let nominal_value = Self::decode_nominal_value(&collection_id, item_id)?;

					Self::deposit_event(Event::<T>::TokenBound { item_id: *item_id });

					Ok((permission, nominal_value))
				}
			})
		}

		/// Unbind a bound permission NFT, releasing its use.
		///
		/// # Errors
		///
		/// - Pallet is not initialized.
		fn unbind(account_id: &T::AccountId) -> Result<T::Balance, DispatchError> {
			BoundTokens::<T>::mutate_exists(account_id, |maybe_item| {
				if let Some(item_id) = *maybe_item {
					*maybe_item = None;
					let collection_id =
						Self::collection_id().ok_or(Error::<T>::CollectionNotInitialized)?;

					<NftsPallet<T> as Transfer<_>>::enable_transfer(&collection_id, &item_id)?;

					Self::deposit_event(Event::<T>::TokenUnbound { item_id });
					Self::decode_nominal_value(&collection_id, &item_id)
				} else {
					Err(Error::<T>::NotBound.into())
				}
			})
		}

		/// Modify the NFTs nominal value to the given amount
		///
		/// # Errors
		/// - Pallet is not initialized
		/// - `new_value` is greater than issued nominal value for the item
		/// - New nominal value could not be encoded
		fn set_nominal_value(item_id: &T::ItemId, new_value: T::Balance) -> DispatchResult {
			let collection_id =
				Self::collection_id().ok_or(Error::<T>::CollectionNotInitialized)?;

			ensure!(
				Self::decode_issued_nominal_value(&collection_id, item_id)? >= new_value,
				Error::<T>::InvalidNominalValue
			);

			Self::encode_nominal_value(&collection_id, item_id, &new_value)
		}

		fn set_nominal_value_of_bound(
			account_id: &T::AccountId,
			new_value: T::Balance,
		) -> DispatchResult {
			let item_id = BoundTokens::<T>::get(account_id).ok_or(Error::<T>::NotBound)?;
			Self::set_nominal_value(&item_id, new_value)
		}

		/// Nominal value of the given NFT.
		///
		/// # Errors
		///
		/// - Pallet is not initialized.
		/// - Attribute decode error.
		fn nominal_value(item_id: &T::ItemId) -> Result<T::Balance, DispatchError> {
			Self::nominal_value_of(item_id)
		}

		/// Issued nominal value of the given NFT.
		///
		/// # Errors
		///
		/// - Pallet is not initialized.
		/// - Attribute decode error.
		fn issued_nominal_value(item_id: &T::ItemId) -> Result<T::Balance, DispatchError> {
			Self::issued_nominal_value_of(item_id)
		}

		fn owner(item_id: &T::ItemId) -> Result<T::AccountId, DispatchError> {
			let collection_id =
				Self::collection_id().ok_or(Error::<T>::CollectionNotInitialized)?;

			NftsPallet::<T>::owner(collection_id, *item_id)
				.ok_or(Error::<T>::ItemNotInitialized.into())
		}

		fn nominal_factor_of(account_id: &T::AccountId) -> Result<Perbill, DispatchError> {
			let collection_id =
				Self::collection_id().ok_or(Error::<T>::CollectionNotInitialized)?;

			let item_id = BoundTokens::<T>::get(account_id).ok_or(Error::<T>::NotBound)?;

			let current = Self::decode_nominal_value(&collection_id, &item_id)?;
			let max = Self::decode_issued_nominal_value(&collection_id, &item_id)?;

			Ok(Perbill::from_rational(current, max))
		}
	}
}
